"""
Created on May 14, 2016

@author: tjoneslo
"""
import logging

from PyRoute.StatCalculation import StatCalculation


class Map(object):
    x_count = 33
    y_count = 41
    y_start = 43
    x_start = 15

    def __init__(self, galaxy, routes):
        self.galaxy = galaxy
        self.routes = routes
        self.ym = 9  # half a hex height
        self.xm = 6  # half the length of one side
        self.colorStart = 0

    def document(self, sector):
        """
        Generated by the type of document
        """
        raise NotImplementedError("Base Class")

    def close(self):
        raise NotImplementedError("Base Class")

    def cursor(self, x, y):
        """
        create a cursor (position) element
        """
        raise NotImplementedError("Base Class")

    def sector_name(self, doc, name):
        """
        Write name at the top of the document
        """
        raise NotImplementedError("Base Class")

    def coreward_sector(self, doc, name):
        raise NotImplementedError("Base Class")

    def rimward_sector(self, doc, name):
        raise NotImplementedError("Base Class")

    def spinward_sector(self, doc, name):
        raise NotImplementedError("Base Class")

    def trailing_sector(self, doc, name):
        raise NotImplementedError("Base Class")

    def add_line(self, doc, start, end, color):
        """
        Add a line to the document, from start to end, in color
        """
        raise NotImplementedError("Base Class")

    def add_circle(self, doc, center, colorname):
        """
        Add a circle to the document, from start to end, in color
        """
        raise NotImplementedError("Base Class")

    def get_line(self, doc, start, end, colorname, width):
        """
        Get a line draw method processor
        """
        raise NotImplementedError("Base Class")
        # color = pdf.get_color()
        # color.set_color_by_name(colorname)
        # hline = PDFLine(pdf.session, pdf.page, hlineStart, hlineEnd, stroke='solid', color=color, size=width)

    def trade_line(self, pdf, edge, data):
        raise NotImplementedError("Base Class")

    @staticmethod
    def string_width(font, string):
        raise NotImplementedError("Base Class")

    def place_system(self, doc, star):
        """
        Write a single world information into the map
        """
        raise NotImplementedError("Base Class")

    def write_sector_pdf_map(self, gal_sector, is_live=True):
        raise NotImplementedError("Base Class")

    def system(self, pdf, star):
        raise NotImplementedError("Base Class")

    def write_maps(self):
        """
        Starting point for writing PDF files.
        Call this to output the trade maps
        """
        logging.getLogger("PyRoute.Map").info("writing {:d} sector maps...".format(len(self.galaxy.sectors)))
        for sector in self.galaxy.sectors.values():
            doc = self.document(sector)
            self.write_base_map(doc, sector)

            self.draw_borders(doc, sector)

            sector_trade = [star for star in self.galaxy.stars.edges(sector.worlds, True)
                            if star[2]['trade'] > 0 and StatCalculation.trade_to_btn(star[2]['trade']) >= self.min_btn]

            logging.getLogger('PyRoute.Map').debug("Worlds with trade: {}".format(len(sector_trade)))

            sector_trade.sort(key=lambda line: line[2]['trade'])

            for (star, neighbor, data) in sector_trade:
                self.galaxy.stars[star][neighbor]['trade btn'] = StatCalculation.trade_to_btn(data['trade'])
                self.trade_line(doc, [star, neighbor], data)

            # Get all the worlds in this sector
            # for (star, neighbor, data) in self.galaxy.stars.edges(sector.worlds, True):
            #    if star.sector != sector:
            #        continue#
            #    if data['trade'] > 0 and self.trade_to_btn(data['trade']) >= self.min_btn:
            #        self.galaxy.stars[star][neighbor]['trade btn'] = self.trade_to_btn(data['trade'])
            #        self.trade_line(doc, [star, neighbor], data)
            #    elif star.sector != neighbor.sector:
            #        data = self.galaxy.stars.get_edge_data(neighbor, star)
            #        if data is not None and \
            #            data['trade'] > 0 and \
            #            self.trade_to_btn(data['trade']) >= self.min_btn:
            #            self.trade_line(doc, [star, neighbor], data)

            for star in sector.worlds:
                self.place_system(doc, star)

            self.close()

    def write_base_map(self, doc, sector):
        self.sector_name(doc, sector.name)
        self.subsector_grid(doc, sector)
        self.hex_grid(doc, self._draw_all, 2)
        if sector.coreward:
            self.coreward_sector(doc, sector.coreward.name)
        if sector.rimward:
            self.rimward_sector(doc, sector.rimward.name)
        if sector.spinward:
            self.spinward_sector(doc, sector.spinward.name)
        if sector.trailing:
            self.trailing_sector(doc, sector.trailing.name)

    def zone(self, doc, star, point):
        point.x_plus(self.xm)
        point.y_plus(self.ym)

        if star.zone in ['R', 'F']:
            self.add_circle(doc, point, self.xm, 'crimson')
        elif star.zone in ['A', 'U']:
            self.add_circle(doc, point, self.xm, 'goldenrod')
        else:  # no zone -> do nothing
            return

    def subsector_grid(self, doc, sector):
        vlineStart = self.cursor(0, self.y_start)
        vlineEnd = self.cursor(0, self.y_start + (180 * 4))
        for x in range(self.x_start, 598, 144):
            if x >= self.x_start + 144:
                x += 3
            vlineStart.x = x
            vlineEnd.x = x
            self.add_line(doc, vlineStart, vlineEnd, 'darkgray')
        hlineStart = self.cursor(self.x_start, 0)
        hlineEnd = self.cursor(594, 0)
        for y in range(self.y_start, 780, 180):
            hlineStart.y = y
            hlineEnd.y = y
            self.add_line(doc, hlineStart, hlineEnd, 'darkgray')

    def hex_grid(self, doc, draw, width, colorname='gray'):

        hlineStart, hlineEnd, hline = self._hline(doc, width, colorname)
        llineStart, llineEnd, lline = self._lline(doc, width, colorname)
        rlineStart, rlineEnd, rline = self._rline(doc, width, colorname)

        for x in range(self.x_count):
            hlineStart.x_plus()
            hlineEnd.x_plus()
            self._hline_restart_y(x, hlineStart, hlineEnd)
            self._lline_restart_y(x, llineStart, llineEnd)
            self._rline_restart_y(x, rlineStart, rlineEnd)

            for y in range(self.y_count):
                hlineStart.y_plus()
                hlineEnd.y_plus()
                llineStart.y_plus()
                llineEnd.y_plus()
                rlineStart.y_plus()
                rlineEnd.y_plus()

                draw(x, y, hline, lline, rline)

            llineStart.x_plus()
            llineEnd.x_plus()
            rlineStart.x_plus()
            rlineEnd.x_plus()

    def _draw_all(self, x, y, hline, lline, rline):
        if (x < self.x_count - 1):
            hline._draw()
        lline._draw()
        if (y > 0):
            rline._draw()

    def _draw_borders(self, x, y, hline, lline, rline):
        q, r = self.convert_hex_to_axial(x + self.sector.dx, y + self.sector.dy - 1)

        if self.galaxy.borders.borders.get((q, r), False):
            if self.galaxy.borders.borders[(q, r)] & 1:
                hline._draw()

            if self.galaxy.borders.borders[(q, r)] & 2 and y > 0:
                rline._draw()

            if self.galaxy.borders.borders[(q, r)] & 4:
                lline._draw()

    def draw_borders(self, pdf, sector):
        self.sector = sector
        self.hex_grid(pdf, self._draw_borders, 1.5, 'salmon')

    @staticmethod
    def convert_hex_to_axial(row, col):
        x = row
        z = col - (row - (row & 1)) / 2
        return (x, z)

    def _hline(self, doc, width, colorname):
        hlineStart = self.cursor(0, 0)
        hlineStart.x = self.x_start - (self.xm * 2)
        hlineStart.y = self.y_start - self.ym
        hlineStart.dx = self.xm * 3
        hlineStart.dy = self.ym * 2

        hlineEnd = self.cursor(0, 0)
        hlineEnd.x = self.x_start
        hlineEnd.y = self.y_start - self.ym
        hlineEnd.dx = self.xm * 3
        hlineEnd.dy = self.ym * 2

        hline = self.get_line(doc, hlineStart, hlineEnd, colorname, width)
        return (hlineStart, hlineEnd, hline)

    def _lline(self, doc, width, colorname):
        llineStart = self.cursor(-10, 0)
        llineStart.x = self.x_start
        llineStart.dx = self.xm * 3
        llineStart.dy = self.ym * 2

        llineEnd = self.cursor(-10, 0)
        llineEnd.x = self.x_start + self.xm
        llineEnd.dx = self.xm * 3
        llineEnd.dy = self.ym * 2

        lline = self.get_line(doc, llineStart, llineEnd, colorname, width)

        return (llineStart, llineEnd, lline)

    def _rline(self, doc, width, colorname):
        rlineStart = self.cursor(0, 0)
        rlineStart.x = self.x_start + self.xm
        rlineStart.dx = self.xm * 3
        rlineStart.dy = self.ym * 2

        rlineEnd = self.cursor(0, 0)
        rlineEnd.x = self.x_start
        rlineEnd.dx = self.xm * 3
        rlineEnd.dy = self.ym * 2

        rline = self.get_line(doc, rlineStart, rlineEnd, colorname, width)
        return (rlineStart, rlineEnd, rline)

    def _hline_restart_y(self, x, hlineStart, hlineEnd):
        if (x & 1):
            hlineStart.y = self.y_start - self.ym
            hlineEnd.y = self.y_start - self.ym
        else:
            hlineStart.y = self.y_start - 2 * self.ym
            hlineEnd.y = self.y_start - 2 * self.ym

    def _lline_restart_y(self, x, llineStart, llineEnd):
        if (x & 1):
            llineStart.y = self.y_start - 2 * self.ym
            llineEnd.y = self.y_start - self.ym
        else:
            llineStart.y = self.y_start - self.ym
            llineEnd.y = self.y_start - 2 * self.ym

    def _rline_restart_y(self, x, rlineStart, rlineEnd):
        if (x & 1):
            rlineStart.y = self.y_start - 3 * self.ym
            rlineEnd.y = self.y_start - 2 * self.ym
        else:
            rlineStart.y = self.y_start - 2 * self.ym
            rlineEnd.y = self.y_start - 3 * self.ym
